;; -*- mode: outline; outline-regexp: " *[-\+]"; indent-tabs-mode: nil; fill-column: 120 -*-

^c^d hide subtree
^c^s show subtree

- redo parser

 - try reverse large file threads
  - reader as main thread and parser is secondary

 - complete all parsers

    extern ojVal	oj_parse_str(ojErr err, const char *json, ojReuser reuser);
    extern ojVal	oj_parse_strp(ojErr err, const char **json, ojReuser reuser);
    extern ojStatus	oj_parse_str_cb(ojErr err, const char *json, ojParseCallback cb, void *ctx);
    extern ojStatus	oj_parse_str_call(ojErr err, const char *json, ojCaller caller);

    extern ojVal	oj_parse_file(ojErr err, const char *filepath, ojReuser reuser); // return on completion of 1 element
    extern ojStatus	oj_parse_file_cb(ojErr err, const char *filepath, ojParseCallback cb, void *ctx);
    extern ojStatus	oj_parse_file_call(ojErr err, const char *filepath, ojCaller caller);

    extern ojVal	oj_parse_fd(ojErr err, int fd, ojReuser reuser); // return on completion of 1 element
     // calling until eof for a follow
    extern ojStatus	oj_parse_fd_cb(ojErr err, int fd, ojParseCallback cb, void *ctx);
    extern ojStatus	oj_parse_fd_call(ojErr err, int fd, ojCaller caller);

    extern ojStatus	oj_pp_parse_str(ojErr		err,
					const char	*json,
					void		(*push)(ojVal val, void *ctx),
					void		(*pop)(void * ctx),
					void		*ctx);
    extern ojStatus	oj_pp_parse_file(ojErr		err,
					const char	*filepath,
					void		(*push)(ojVal val, void *ctx),
					void		(*pop)(void * ctx),
					void		*ctx);
    extern ojStatus	oj_pp_parse_fd(ojErr		err,
					int             fd,
					void		(*push)(ojVal val, void *ctx),
					void		(*pop)(void * ctx),
					void		*ctx);


 - function to use case of doing something to a log file
  - compare time range
  - walk to touch everything as if reformatting to display
  - regex on something like the msg

 - single app for benchmark results
   - app <parse|file|validate|write> <filename> <iter>
   - output is json {name, duration, mem-use, error}
  - bench app takes list of apps to run


 - val parse tests

- val create functions

- make sure follow works

- compare other libs
 - :question: for not exactly follow by a number for comment/note
 - :x: for not supported
 - :white_check_mark: for supported or maybe :ok:
 - validate (test for these)
  - structure comma
  - structure close
  - string chars (\t in string)
  - numbers (multiple . e -)
  - big numbers accepted? (1.2e310 or int with more than 20 digits)
   - maybe show max digits and exp (16 vs 19 vs no limit)
  - display error location?
 - can get complete values as native types (array and object should be iteratable)
 - big numbers
 - long double or maybe precision (80 bit vs 64)
 - save for later (how to do with others?)
 - multiple json in one file (any allowable format)
 - multiple with one json per line
 - small file (under 4G)
 - medium file (over 4G)
 - large file (larger than memory)
- performance (speed and memory use)
 - validate (no checking that values were extracted) (mark as not really validated if compare shows invalid are not detected)
 - single file as string (patient)
 - mutiple file (small)
 - mutiple file (4G)
 - mutiple file (large)
 - build/modify
 - to string
 - write

- TBD stream write functions someday

- article
 - x vs OjC
 - cast as a set of field events
  - start as boxing but then nix that idea as too confrontational
  - start with goodwill that it is a competition but friendly
 - explain the competitors
  - team size, participants and support
  - breadth of events
 - maybe event team member match to function(s)
