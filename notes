;; -*- mode: outline; outline-regexp: " *[-\+]"; indent-tabs-mode: nil; fill-column: 120 -*-

^c^d hide subtree
^c^s show subtree

- redo parser

- val create functions


 - function to use case of doing something to a log file
  - compare time range
  - walk to touch everything as if reformatting to display
  - regex on something like the msg

 - single app for benchmark results
   - app <parse|file|validate|write> <filename> <iter>
   - output is json {name, duration, mem-use, error}
  - bench app takes list of apps to run


 - val parse tests

- compare other libs
 - :question: for not exactly follow by a number for comment/note
 - :x: for not supported
 - :white_check_mark: for supported or maybe :ok:
 - validate (test for these)
  - structure comma
  - structure close
  - string chars (\t in string)
  - numbers (multiple . e -)
  - big numbers accepted? (1.2e310 or int with more than 20 digits)
   - maybe show max digits and exp (16 vs 19 vs no limit)
  - display error location?
 - can get complete values as native types (array and object should be iteratable)
 - big numbers
 - long double or maybe precision (80 bit vs 64)
 - save for later (how to do with others?)
 - multiple json in one file (any allowable format)
 - multiple with one json per line
 - small file (under 4G)
 - medium file (over 4G)
 - large file (larger than memory)
 - docs
 - examples
- performance (speed and memory use)
 - validate (no checking that values were extracted) (mark as not really validated if compare shows invalid are not detected)
 - single file as string (patient)
 - mutiple file (small)
 - mutiple file (4G)
 - mutiple file (large)
 - build/modify
 - to string
 - write

- TBD stream write functions someday

- article
 - x vs OjC
 - cast as a set of field events
  - start as boxing but then nix that idea as too confrontational
  - start with goodwill that it is a competition but friendly
 - explain the competitors
  - team size, participants and support
  - breadth of events
 - maybe event team member match to function(s)
