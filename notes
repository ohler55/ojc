;; -*- mode: outline; outline-regexp: " *[-\+]"; indent-tabs-mode: nil; fill-column: 120 -*-

^c^d hide subtree
^c^s show subtree

- redo parser
 - ojDestroyer
  - better name? ojReuse ?

 - more efficient destroy
  - have cb return a op code
   - OJ_CONTINUE - 0x00
   - OJ_STOP - 0x01
   - OJ_DESTROY 0x02

  - maybe keep list on parser and set all_head and all_tail on returned value
   - if free_head present then use it else process with the current way
   - maybe a free_me struct being populated for destroy
    - would need to give that to cb in some manner
   - also any allocated blocks and s4ks
   - maybe put special ones on another list and process those first
    - what to use for links on second
     - maybe since it will be last added it can just be moved right away
   - oj_destroy_all(ojAll all)
    - maybe another reuse allocator
    - dig - dig into each and destroy (string and big only)
    - rest or reg(ular)

 - single app for benchmark results
   - app <parse|file|validate|write> <filename> <iter>
   - output is json {name, duration, mem-use, error}
  - bench app takes list of apps to run

 - val parse tests

 - hash

- make sure follow works

- compare other libs
 - :question: for not exactly follow by a number for comment/note
 - :x: for not supported
 - :white_check_mark: for supported or maybe :ok:
 - validate (test for these)
  - structure comma
  - structure close
  - string chars (\t in string)
  - numbers (multiple . e -)
  - big numbers accepted? (1.2e310 or int with more than 20 digits)
   - maybe show max digits and exp (16 vs 19 vs no limit)
  - display error location?
 - can get complete values as native types (array and object should be iteratable)
 - big numbers
 - long double or maybe precision (80 bit vs 64)
 - save for later (how to do with others?)
 - multiple json in one file (any allowable format)
 - multiple with one json per line
 - small file (under 4G)
 - medium file (over 4G)
 - large file (larger than memory)
- performance (speed and memory use)
 - validate (no checking that values were extracted) (mark as not really validated if compare shows invalid are not detected)
 - single file as string (patient)
 - mutiple file (small)
 - mutiple file (4G)
 - mutiple file (large)
 - build/modify
 - to string
 - write

- TBD stream write functions someday

- article
 - x vs OjC
 - cast as a set of field events
  - start as boxing but then nix that idea as too confrontational
  - start with goodwill that it is a competition but friendly
 - explain the competitors
  - team size, participants and support
  - breadth of events
 - maybe event team member match to function(s)
